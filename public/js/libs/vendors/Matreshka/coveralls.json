{"source_files":[{"name":"test/src/bindings/binders_spec.es","source":"import magic from 'matreshka-magic';\nimport $ from 'bquery';\nlet q = (s, c) => $(s, c)[0] || null;\n\n// TODO how to test file binder?\n// TODO test DOM events too\n\ndescribe('Binders', () => {\n    it('Binds prop', () => {\n        let node = $.create('div', {someProp: 42}),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.prop('someProp'));\n\n        expect(o.x).toEqual(42);\n        o.x = 43;\n        expect(node.someProp).toEqual(43);\n    });\n\n    it('Binds attr', () => {\n        let node = $.create('div', {attributes: {someattr: \"42\"}}),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.attr('someattr'));\n\n        expect(o.x).toEqual('42');\n        o.x = 43;\n        expect(node.getAttribute('someattr')).toEqual('43');\n    });\n\n    it('Binds html', () => {\n        let node = $.create('div', {innerHTML: '<i>42</i>'}),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.html());\n\n        expect(o.x).toEqual('<i>42</i>');\n        o.x = '<i>43</i>';\n        expect(node.innerHTML).toEqual('<i>43</i>');\n    });\n\n\n    it('Binds text', () => {\n        let node = $.create('div', {textContent: '<i>42</i>'}),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.text());\n\n        expect(o.x).toEqual('<i>42</i>');\n        o.x = '<i>43</i>';\n        expect(node.textContent).toEqual('<i>43</i>');\n    });\n\n\n    it('Binds style', () => {\n        let node = $.create('div', {style: {textAlign: 'center'}}),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.style('textAlign'));\n\n        expect(o.x).toEqual('center');\n        o.x = 'right';\n        expect(node.style.textAlign).toEqual('right');\n    });\n\n\n    it('Binds display', () => {\n        let node = $.create('div'),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.display());\n\n        expect(o.x).toEqual(true);\n        o.x = false;\n        expect(node.style.display).toEqual('none');\n\n        magic.bindNode(o, 'y', node, magic.binders.display(false));\n\n        expect(o.y).toEqual(true);\n        o.y = false;\n        expect(node.style.display).toEqual('');\n    });\n\n    it('Binds dataset', () => {\n        let node = $.create('div', {\n                attributes: {'data-some-attr': '42'}\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.dataset('someAttr'));\n\n        expect(o.x).toEqual('42');\n        o.x = '43';\n        expect(node.getAttribute('data-some-attr')).toEqual('43');\n    });\n\n    it('Binds className', () => {\n        let node = $.create('div', {\n                className: 'some-class'\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node, magic.binders.className('some-class'));\n\n        expect(o.x).toEqual(true);\n        o.x = false;\n        expect(node.classList.contains('some-class')).toEqual(false);\n\n\n        magic.bindNode(o, 'y', node, magic.binders.className('!some-class'));\n\n        expect(o.y).toEqual(true);\n        o.y = false;\n        expect(node.classList.contains('some-class')).toEqual(true);\n    });\n\n    it('supports fallbacks', () => {\n        expect(magic.binders.innerHTML).toEqual(magic.binders.html);\n        expect(magic.binders.innerText).toEqual(magic.binders.text);\n        expect(magic.binders.property).toEqual(magic.binders.prop);\n        expect(magic.binders.attribute).toEqual(magic.binders.attr);\n    });\n});\n\n\ndescribe('Default binders', () => {\n    it('Binds textarea', () => {\n        let node = $.create('textarea', {\n                value: '42'\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n\n        expect(o.x).toEqual('42');\n        o.x ='43';\n        expect(node.value).toEqual('43');\n    });\n\n    it('Binds progress', () => {\n        let node = $.create('progress', {\n                max: 100,\n                value: 42\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n        expect(o.x).toEqual(42);\n        o.x = 43;\n        expect(node.value).toEqual(43);\n    });\n\n    it('Binds text input', () => {\n        let node = $.create('input', {\n                value: '42'\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n\n        expect(o.x).toEqual('42');\n        o.x ='43';\n        expect(node.value).toEqual('43');\n    });\n\n    it('Binds checkbox', () => {\n        let node = $.create('input', {\n                type: 'checkbox',\n                checked: true\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n\n        expect(o.x).toEqual(true);\n        o.x = false;\n        expect(node.checked).toEqual(false);\n    });\n\n    it('Binds select', () => {\n        let node = $.create('select', {\n                children: [{\n                    tagName: 'option',\n                    value: '1'\n                }, {\n                    tagName: 'option',\n                    selected: true,\n                    value: '2'\n                }, {\n                    tagName: 'option',\n                    value: '3'\n                }, {\n                    tagName: 'option',\n                    value: '4'\n                }]\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n\n        expect(o.x).toEqual('2');\n        o.x = '3';\n        expect(node.options[node.selectedIndex].value).toEqual('3');\n    });\n\n\n    it('Binds output', () => {\n        let node = $.create('output', {\n                innerHTML: '42'\n            }),\n            o = {};\n\n        magic.bindNode(o, 'x', node);\n\n        expect(o.x).toEqual('42');\n        o.x = '43';\n        expect(node.innerHTML).toEqual('43');\n    });\n});\n","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,0,null,null,1,1,1,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,1,null,1,1,1,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,1,null,1,1,1,null,1,null,1,1,1,null,1,1,1,1,1,null,null,1,1,1,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,1,null,1,1,1]},{"name":"test/src/common/remove_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe(\"remove\", () => {\n\tit('removes', () => {\n\t\tlet obj = {\n\t\t\ta: 1\n\t\t};\n\n\t\tmagic.remove(obj, 'a')\n\n\t\texpect('a' in obj).toBe(false);\n\t});\n\n\tit('removes special', () => {\n\t\tlet obj = {\n\t\t\ta: 1\n\t\t};\n\n\t\tmagic._defineSpecial(obj, 'a');\n\n\t\tmagic.remove(obj, 'a');\n\n\t\texpect('a' in obj).toBe(false);\n\t});\n});","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,null,1,null,1,null,1,1,null,null,null,1,null,1,null,1]},{"name":"test/src/bindings/bindings_parser_spec.es","source":"import magic from 'matreshka-magic';\nimport $ from 'bquery';\nlet q = (s, c) => $(s, c)[0] || null;\n\n\ndescribe('Bindings parser', () => {\n    it('should bind HTML', () => {\n        let node = q('<span>{{x}}</span>'),\n            object = {};\n        //document.body.appendChild(node);\n        magic.parseBindings(object, node);\n        object.x = 'hi';\n        expect(node.firstChild.innerHTML).toEqual(object.x);\n\t});\n\n\n    it('should bind values', () => {\n        let node = q('<input value=\"{{x}}\">'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = 'hey';\n        expect(node.value).toEqual(object.x);\n\t});\n\n\n    it('should bind checked', () => {\n        let node = q('<input type=\"checkbox\" checked=\"{{x}}\">'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = true;\n        expect(node.checked).toEqual(object.x);\n\t});\n\n\n    it('should bind textareas', () => {\n        let node = q('<textarea value=\"{{x}}\"></textarea>'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = 'foo';\n        expect(node.value).toEqual(object.x);\n\t});\n\n\n    it('should bind complex attrs', () => {window.ololosha = true;\n        let node = q('<a href=\"{{x}}/{{y}}\"></a>'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = 'bar';\n        object.y = 'baz';\n        expect(node.getAttribute('href')).toEqual(object.x + '/' + object.y);window.ololosha = false;\n\t});\n\n\n    it('should bind complex values', () => {\n        let node = q('<input value=\"{{x}} and {{y}}\">'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = 'foo';\n        object.y = 'bar';\n        expect(node.value).toEqual(object.x + ' and ' + object.y);\n\t});\n\n\n    it('shouldnt create additional properties', () => {\n        let node = q('<input value=\"{{x}} and {{y}}\">'),\n            object = {};\n        magic.parseBindings(object, node);\n        object.x = 'bar';\n        object.y = 'baz';\n        expect(node.value).toEqual(object.x + ' and ' + object.y);\n        expect(Object.keys(object)).toEqual(['x', 'y']);\n\t});\n\n\n    it('should bind nested nodes', () => {\n        let node = q(`\n            <div>{{x}}\n                <input value=\"{{y}}\">\n                <span>\n                    <span>\n                        <span attr=\"hey {{z}}\"></span>\n                    </span>\n                </span>\n            </div>\n        `),\n        object = {};\n        magic.parseBindings(object, node);\n        object.x = 'foo';\n        object.y = 'bar';\n        object.z = 'baz';\n        expect(node.innerHTML.indexOf('<span>' + object.x + '</span>')).toEqual(0);\n        expect(q('input', node).value).toEqual(object.y);\n        expect(q('[attr]', node).getAttribute('attr')).toEqual('hey ' + object.z);\n        expect(Object.keys(object).sort()).toEqual(['x', 'y', 'z']);\n\t});\n\n    it('should bind nested nodes and deep properties', () => {\n        let node = q(`\n            <div>{{a.b}}\n                <input value=\"{{c.d}}\">\n                <span>\n                    <span>\n                        <span attr=\"hey {{e.f}}\"></span>\n                    </span>\n                </span>\n            </div>\n        `),\n        object = {\n            a: {b: 1},\n            c: {d: 2},\n            e: {f: 2}\n        };\n        magic.parseBindings(object, node);\n        object.a.b = 'foo';\n        object.c.d = 'bar';\n        object.e.f = 'baz';\n        expect(node.innerHTML.indexOf('<span>' + object.a.b + '</span>')).toEqual(0);\n        expect(q('input', node).value).toEqual(object.c.d);\n        expect(q('[attr]', node).getAttribute('attr')).toEqual('hey ' + object.e.f);\n\t});\n\n\tit('works when brackets are redefined', () => {\n        let node = q('<input value=\"[[x]] you\">'),\n            object = {},\n\t\t\tdefaultBrackets = magic.parserBrackets;\n\n\t\tmagic.parserBrackets = {\n\t\t\tleft: '[[',\n\t\t\tright: ']]'\n\t\t};\n\n        magic.parseBindings(object, node);\n        object.x = 'hey';\n        expect(node.value).toEqual(object.x + ' you');\n\n\t\tmagic.parserBrackets = defaultBrackets;\n\t})\n});\n","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,14,null,null,1,1,1,null,null,1,null,1,1,null,1,1,null,null,1,null,1,1,null,1,1,null,null,1,null,1,1,null,1,1,null,null,1,null,1,1,null,1,1,1,null,null,1,null,1,1,1,1,null,1,1,null,null,1,null,1,1,1,null,1,1,null,null,1,null,1,1,1,1,null,1,1,null,null,1,null,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,1,null,1,1,null,null,1,null,null,null,null,1,null,1,1,1,null]},{"name":"test/src/bindings/bindings_spec.es","source":"import magic from 'matreshka-magic';\nimport MK from 'matreshka';\nimport $ from 'bquery';\nlet q = (s, c) => $(s, c)[0] || null;\n\nlet bindInput = (obj, key, evt) => {\n\tlet input = $.create('input');\n\tmagic.bindNode(obj, key, input, {\n\t\ton(cbc) {\n\t\t\t\tthis._onkeyup = cbc;\n\t\t\t},\n\t\t\tgetValue() {\n\t\t\t\treturn this.value;\n\t\t\t},\n\t\t\tsetValue(v) {\n\t\t\t\tthis.value = v;\n\t\t\t}\n\t}, evt);\n\n\treturn input;\n};\n\ndescribe('Bindings', () => {\n\tit('should bind', () => {\n\t\tlet obj = {},\n\t\t\tinput = bindInput(obj, 'x');\n\n\t\tobj.x = 'foo';\n\t\texpect(input.value).toEqual('foo');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x).toEqual('bar');\n\t});\n\n\n\tit('should unbind', () => {\n\t\tlet obj = {},\n\t\t\tinput = bindInput(obj, 'x');\n\n\t\tmagic.unbindNode(obj, 'x', input);\n\n\t\tobj.x = 'foo';\n\t\texpect(input.value).toEqual('');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x).toEqual('foo');\n\t});\n\n\n\tit('should bind delegated target', () => {\n\t\tlet obj = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput = bindInput(obj, 'x.y.z');\n\n\t\tobj.x.y.z = 'foo';\n\t\texpect(input.value).toEqual('foo');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x.y.z).toEqual('bar');\n\t});\n\n\n\tit('should unbind delegated target', () => {\n\t\tlet obj = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput = bindInput(obj, 'x.y.z');\n\n\t\tmagic.unbindNode(obj, 'x.y.z', input);\n\n\t\tobj.x.y.z = 'foo';\n\t\texpect(input.value).toEqual('');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x.y.z).toEqual('foo');\n\t});\n\n\tit('should rebind delegated target', () => {\n\t\tlet obj = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput = bindInput(obj, 'x.y.z');\n\n\t\tobj.x = {\n\t\t\ty: {\n\t\t\t\tz: 'foo'\n\t\t\t}\n\t\t};\n\t\texpect(input.value).toEqual('foo');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x.y.z).toEqual('bar');\n\t});\n\n\tit('should remove binding if delegated target is reassigned', () => {\n\t\tlet obj = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput = bindInput(obj, 'x.y.z'),\n\t\t\tx = obj.x;\n\n\t\tobj.x = {\n\t\t\ty: {\n\t\t\t\tz: 'foo'\n\t\t\t}\n\t\t};\n\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(x.y.z).not.toEqual('bar');\n\t\texpect(obj.x.y.z).toEqual('bar');\n\t});\n\n\n\tit('uses custom selectors on current target', () => {\n\t\tlet obj = MK.to({x: {y: 'foo'}}),\n\t\t \tdiv = $.create('div'),\n\t\t\tinput = div.appendChild($.create('input'));\n\n\t\tobj.bindNode('sandbox', div);\n\t\tobj.bindNode('x.y', ':sandbox input', {\n\t\t\ton(cbc) {\n\t\t\t\tthis._onkeyup = cbc;\n\t\t\t}\n\t\t});\n\n\t\texpect(input.value).toEqual('foo');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj.x.y).toEqual('bar');\n\t});\n\n\n\tit('throws error when node isn\\'t there', () => {\n\t\tlet obj = {},\n\t\t\terror = false;\n\n\t\ttry {\n\t\t\tmagic.bindNode(obj, 'x');\n\t\t} catch(e) {\n\t\t\terror = true;\n\t\t}\n\n\t\texpect(error).toBe(true);\n\t});\n\n\tit('doesn\\'t throw error with bindOptionalNode when node is missing', () => {\n\t\tlet obj = {};\n\n\t\tmagic.bindOptionalNode(obj, 'x');\n\n\t\texpect(true).toBe(true);\n\t});\n\n\n\tit('returns bound nodes', () => {\n\t\tlet obj = {},\n\t\t\tinput = bindInput(obj, 'x');\n\n\n\t\texpect(input).toEqual(magic.bound(obj, 'x'));\n\t\texpect(input).toEqual(magic.$bound(obj, 'x')[0]);\n\t});\n\n\n\tit('selects children of sandbox', () => {\n\t\tlet obj = {};\n\n\t\tmagic.bindNode(obj, 'sandbox', `<div>\n\t\t\t\t<div>\n\t\t\t\t\t<span></span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`);\n\n\t\texpect('SPAN').toEqual(magic.select(obj, 'span').tagName);\n\t\texpect('SPAN').toEqual(magic.selectAll(obj, 'span')[0].tagName);\n\t});\n\n\n\tit('selects nodes with custom selector', () => {\n\t\tlet obj = {};\n\n\t\tmagic.bindNode(obj, 'sandbox', `<div>\n\t\t\t\t<div>\n\t\t\t\t\t<span></span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`);\n\n\t\texpect('SPAN').toEqual(magic.select(obj, ':bound(sandbox) span').tagName);\n\t\texpect('SPAN').toEqual(magic.selectAll(obj, ':sandbox span')[0].tagName);\n\t});\n\n\tit('cancels deep binding via deep: false', () => {\n\t\tlet obj = {},\n\t\t\tinput = bindInput(obj, 'a.b', {\n\t\t\t\tdeep: false\n\t\t\t});\n\n\t\tobj['a.b'] = 'foo';\n\t\texpect(input.value).toEqual('foo');\n\t\tinput.value = 'bar';\n\t\tinput._onkeyup({});\n\t\texpect(obj['a.b']).toEqual('bar');\n\t});\n\n\n\tit('allows to debounce handler', done => {\n\t\tlet obj = {},\n\t\t\tinput = bindInput(obj, 'x', {\n\t\t\t\tdebounce: true\n\t\t\t});\n\n\t\tobj.x = 'foo';\n\t\texpect(input.value).toEqual('');\n\t\tobj.x = 'bar';\n\t\texpect(input.value).toEqual('');\n\n\t\tsetTimeout(() => {\n\t\t\texpect(input.value).toEqual('bar');\n\t\t\tdone();\n\t\t}, 400);\n\t});\n});\n","coverage":[null,null,1,1,null,1,null,1,null,1,3,null,null,null,null,1,0,null,null,1,9,null,9,null,11,null,null,14,null,null,14,null,null,null,9,null,null,1,1,1,null,1,1,1,null,1,null,1,null,1,1,null,null,1,null,1,1,1,null,1,null,1,null,1,1,null,null,null,null,null,1,1,1,null,1,null,1,null,1,1,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,1,1,null,null,null,null,null,1,null,null,null,null,1,1,null,1,null,1,null,1,1,null,null,null,null,null,null,1,null,null,null,null,1,null,1,null,1,1,null,1,1,null,null,null,null,null,null,null,1,1,null,1,null,null,1,1,null,1,null,1,null,1,1,null,null,1,1,null,1,null,null,1,null,1,1,null,1,null,1,null,1,1,null,1,1,null,1,1,null,1,null,1,1,null,1,1,null,1,null,1,1,null,1,1,null,null,null,1,1,1,null,1,null,1,null,1,1,null,null,null,1,1,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/bindings/getnodes_spec.es","source":"import MK from 'matreshka';\nimport $ from 'bquery';\n\n\ndescribe('Getting bound nodes', () => {\n    it('nodes and $nodes exist', () => {\n        let node = $.create('div'),\n            mk = new MK;\n\n        mk.bindNode('x', node);\n\n        expect(mk.nodes.x).toEqual(node);\n        expect(mk.$nodes.x[0]).toEqual(node);\n    });\n\n    it('sandbox and $sandbox exist', () => {\n        let node = $.create('div'),\n            mk = new MK;\n\n        mk.bindNode('sandbox', node);\n\n        expect(mk.sandbox).toEqual(node);\n        expect(mk.$sandbox[0]).toEqual(node);\n    });\n\n    it('bound and $bound work', () => {\n        let node = $.create('div'),\n            mk = new MK;\n\n        mk.bindNode('x', node);\n\n        expect(mk.bound('x')).toEqual(node);\n        expect(mk.$bound('x')[0]).toEqual(node);\n    });\n\n    it('bound and $bound work with no argument', () => {\n        let node = $.create('div'),\n            mk = new MK;\n\n        mk.bindNode('sandbox', node);\n\n        expect(mk.bound()).toEqual(node);\n        expect(mk.$bound()[0]).toEqual(node);\n    });\n\n    it('bound and $bound work with deep bindings', () => {\n        let node = $.create('div'),\n            o = {a: {b: {c: {}}}};\n\n        MK.bindNode(o, 'a.b.c', node);\n\n        expect(MK.bound(o, 'a.b.c')).toEqual(node);\n        expect(MK.$bound(o, 'a.b.c')[0]).toEqual(node);\n    });\n});\n","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,1,1,null,null,1,1,1,null,1,1,null,null,1,1,1,null,1,1,null,null,1,1,1,null,1,1,null,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,1,1]},{"name":"test/src/bquery/events_spec.es","source":"import $ from 'bquery';\n\nlet click = node => {\n    let ev = document.createEvent(\"MouseEvent\");\n    ev.initMouseEvent(\n        \"click\",\n        true /* bubble */ , true /* cancelable */ ,\n        window, null,\n        0, 0, 0, 0, /* coordinates */\n        false, false, false, false, /* modifier keys */\n        0 /*left*/ , null\n    );\n    node.dispatchEvent(ev);\n}\n\n/* TODO:\n    Test $ with various values\n    Test addClass, removeClass\n*/\n\ndescribe(\"bQuery Events\", () => {\n    document.body.appendChild($.create('div', {\n        id: 'bquery-test',\n        innerHTML: `\n        <div class=\"child1\">\n            <div class=\"grandchild1\"></div>\n        </div>\n        <div class=\"child2\"></div>`\n    }))\n\n    var parent = document.getElementById('bquery-test'),\n        child1 = parent.querySelector('.child1'),\n        child2 = parent.querySelector('.child2'),\n        grandchild1 = parent.querySelector('.grandchild1');\n\n    //setTimeout(() => document.body.removeChild(parent), 1000);\n\n    it('Adds event listener', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', f);\n        click(parent);\n\n        expect(bool).toEqual(true);\n\t});\n\n    it('Removes event listener (listener is specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n        $(parent)\n            .on('click', f)\n            .off('click', f);\n\n        click(parent);\n\n        expect(bool).toEqual(false);\n\t});\n\n\n    it('Removes event listener (listener is not specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n        $(parent)\n            .on('click', f)\n            .off('click');\n\n        click(parent);\n\n        expect(bool).toEqual(false);\n\t});\n\n    it('Adds namespaced listener', () => {\n        let bool = false;\n        $(parent).on('click.yo', evt => bool = true);\n\n        click(parent);\n\n        expect(bool).toEqual(true);\n\n        $(parent).off('click.yo');\n\t});\n\n    it('Removes namespaced listener (listener is specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n        $(parent).on('click.yo', f);\n        $(parent).off('click.yo', f);\n\n        click(parent);\n\n        expect(bool).toEqual(false);\n\t});\n\n    it('Removes namespaced listener (listener is not specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n        $(parent).on('click.yo', f);\n        $(parent).off('click.yo');\n\n        click(parent);\n\n        expect(bool).toEqual(false);\n\t});\n\n    it('Adds bubbling event listener', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', f);\n\n        click(grandchild1);\n\n        expect(bool).toEqual(true);\n\n        $(parent).off('click', f);\n    });\n\n    it('Adds delegated event listener', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n\n        click(child1);\n\n        expect(bool).toEqual(true);\n\n        $(parent).off('click','.child1', f);\n    });\n\n    it('Adds delegated event listener (click on grandchildren)' , () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n\n        click(grandchild1);\n\n        expect(bool).toEqual(true);\n\n        $(parent).off('click', '.child1', f);\n    });\n\n    it('Doesn\\t trigger when clicked on wrong child', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n\n        click(child2);\n\n        expect(bool).toEqual(false);\n    });\n\n    it('Removes delegated event listener (selector and handler are specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n        $(parent).off('click', '.child1', f);\n\n        click(child1);\n\n        expect(bool).toEqual(false);\n    });\n\n    it('Removes delegated event listener (selector is specified, handler is not specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n        $(parent).off('click', '.child1');\n\n        click(child1);\n\n        expect(bool).toEqual(false);\n    });\n\n    it('Removes delegated event listener (selector is not specified, handler is specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n        $(parent).off('click', f);\n\n        click(child1);\n\n        expect(bool).toEqual(false);\n    });\n\n    it('Removes delegated event listener (selector and handler are not specified)', () => {\n        let bool = false,\n            f = evt => bool = true;\n\n        $(parent).on('click', '.child1', f);\n        $(parent).off('click');\n\n        click(child1);\n\n        expect(bool).toEqual(false);\n    });\n\n\n    it('Stops propagation', () => {\n        let bool = false,\n            f = evt => bool = true,\n            f2 = evt => evt.stopPropagation();\n\n        $(parent).on('click', f);\n        $(child1).on('click', f2);\n\n\n        click(child1);\n\n        expect(bool).toEqual(false);\n\n        $(child1).off('click');\n        $(parent).off('click');\n    });\n\n\n    /*it('Stops propagation for delegated events', () => {\n        let bool = false,\n            f = evt => bool = true,\n            f2 = evt => evt.stopPropagation();\n\n        $(parent).on('click', '.child1', f);\n        $(parent).on('click', '.grandchild1', f2);\n\n        click(grandchild1);\n\n        expect(bool).toEqual(false);\n\n        $(parent).off('click');\n    });*/\n\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,15,15,15,null,null,1,1,null,null,null,1,null,null,null,1,1,null,2,null,null,1,1,1,null,1,1,null,0,null,null,1,1,1,null,1,1,null,0,null,null,1,1,1,null,1,1,1,1,null,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,1,null,null,1,1,1,1,null,1,1,null,1,null,null,1,1,1,1,null,1,1,null,1,null,null,1,1,1,1,null,1,1,null,1,null,null,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,0,null,null,1,1,1,1,null,1,1,null,0,null,null,1,null,null,1,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/events/events_change_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe(\"Change event\", () => {\n\tit('fires (x)', () => {\n\t\tlet obj = {\n\t\t\t\tx: 1\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._addListener(obj, 'change:x', evt => bool = true);\n\n\t\tobj.x = 2;\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (delegated, a.x)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tx: 1\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a', 'change:x', evt => bool = true);\n\n\t\tobj.a.x = 2;\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (delegated, a.b.x)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tx: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b', 'change:x', evt => bool = true);\n\n\t\tobj.a.b.x = 2;\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (delegated, a.b.x)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tx: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b', 'change:x', evt => bool = true);\n\n\t\tobj.a.b.x = 2;\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when delegated target is reassigned (a.b.c.x, reassign a)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\tx: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => bool = true);\n\t\tobj.a = {\n\t\t\tb: {\n\t\t\t\tc: {\n\t\t\t\t\tx: 2\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when delegated target is reassigned (a.b.c.x, reassign b)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\tx: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => bool = true);\n\t\tobj.a.b = {\n\t\t\tc: {\n\t\t\t\tx: 2\n\t\t\t}\n\t\t};\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when delegated target is reassigned (a.b.c.x, reassign c)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\tx: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => bool = true);\n\t\tobj.a.b.c = {\n\t\t\tx: 2\n\t\t};\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('avoids conflicts', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\tx: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ti = 0;\n\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e11);\n\t\tmagic._delegateListener(obj, 'a.b', 'change:c', evt => i += 1e10);\n\t\tmagic._delegateListener(obj, 'a.b', 'change:c', evt => i += 1e9);\n\t\tmagic._delegateListener(obj, 'a.b', 'change:c', evt => i += 1e8);\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => i += 1e7);\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => i += 1e6);\n\t\tmagic._delegateListener(obj, 'a.b.c', 'change:x', evt => i += 1e5);\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e4);\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e3);\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e2);\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e1);\n\t\tmagic._delegateListener(obj, 'a', 'change:b', evt => i += 1e0);\n\t\tobj.a = {\n\t\t\tb: {\n\t\t\t\tc: {\n\t\t\t\t\tx: 2\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\texpect(i).toEqual(111111111111);\n\t});\n\n\tit('accepts null target (a.b.c, reassign b)', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\tx: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', evt => bool = true);\n\n\t\tobj.a.b = null;\n\n\t\texpect(bool).toBe(false);\n\t});\n});","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,null,null,1,1,null,null,1,1,null,1,1,null,null,null,null,null,null,1,1,null,null,1,1,null,1,1,null,null,null,null,null,null,null,null,1,1,null,null,1,1,null,1,1,null,null,null,null,null,null,null,null,1,1,null,null,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,0,null,null,1,1]},{"name":"test/src/events/events_core_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe(\"Events core: _addListener, _removeListener, trigger\", () => {\n\n\tit('fires', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\t\tmagic._addListener(obj, 'someevent', evt => bool = true);\n\t\tmagic.trigger(obj, 'someevent');\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('avoids conflicts', () => {\n\t\tlet obj = {},\n\t\t\ti = 0;\n\t\tmagic._addListener(obj, 'someevent', evt => i += 1e0);\n\t\tmagic._addListener(obj, 'someevent', evt => i += 1e1);\n\t\tmagic._addListener(obj, 'someevent', evt => i += 1e2);\n\t\tmagic.trigger(obj, 'someevent');\n\t\texpect(i).toEqual(111);\n\t});\n\n\tit('removes (no args)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true;\n\n\t\tmagic._addListener(obj, 'someevent', f);\n\t\tmagic._removeListener(obj, 'someevent');\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes by callback', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true;\n\n\t\tmagic._addListener(obj, 'someevent', f);\n\t\tmagic._removeListener(obj, 'someevent', f);\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes by callback but keeps when callbacks are not same', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true;\n\n\t\tmagic._addListener(obj, 'someevent', f);\n\t\tmagic._removeListener(obj, 'someevent', () => {});\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removes by callback and context', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tctx = {};\n\n\t\tmagic._addListener(obj, 'someevent', f, ctx);\n\t\tmagic._removeListener(obj, 'someevent', f, ctx);\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes by callback but keeps when contexts are not same', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tctx = {};\n\n\t\tmagic._addListener(obj, 'someevent', f, ctx);\n\t\tmagic._removeListener(obj, 'someevent', f, {});\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removes by howToRemove (not documented core feature)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tonData = {\n\t\t\t\thowToRemove(onData, offData) {\n\t\t\t\t\treturn offData.x === 42;\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._addListener(obj, 'someevent1', f, null, onData);\n\t\tmagic._removeListener(obj, 'someevent1', null, null, {\n\t\t\tx: 42\n\t\t});\n\n\t\tmagic.trigger(obj, 'someevent1');\n\n\t\texpect(bool).toBe(false);\n\n\t\tmagic._addListener(obj, 'someevent2', f, null, onData);\n\t\tmagic._removeListener(obj, 'someevent2', null, null, {\n\t\t\tx: 43\n\t\t});\n\n\t\tmagic.trigger(obj, 'someevent2');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n});\n\n\n// change events\n// dom events\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,1,1,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,1,null,null,1,1,null,null,1,null,1,null,1,1,null,null,0,null,null,1,null,1,null,1,null,1,null,1,1,null,null,0,null,null,1,null,1,null,1,null,1,null,1,1,null,null,1,null,null,1,null,1,null,1,null,1,null,1,1,null,null,0,null,null,null,1,null,1,null,1,null,1,null,1,1,null,null,1,null,null,null,1,null,1,null,1,null,1,null,1,1,null,null,1,null,null,null,2,null,null,null,1,null,1,null,null,null,1,null,1,null,1,null,1,null,null,null,1,null,1]},{"name":"test/src/events/events_delegated_spec.es","source":"import magic from 'matreshka-magic';\nimport MK from 'matreshka';\n\ndescribe('Delegated events: _delegateListener, _undelegateListener', () => {\n\tit('fires (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when reassigned (a.b, reassign a)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tobj.a = {\n\t\t\tb: {}\n\t\t};\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when reassigned (a.b, reassign b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tobj.a.b = {};\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when reassigned (a.b.c, reassign a)', () => {\n\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a = {\n\t\t\tb: {\n\t\t\t\tc: {}\n\t\t\t}\n\t\t};\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when reassigned (a.b.c, reassign b)', () => {\n\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a.b = {\n\t\t\tc: {}\n\t\t};\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires when reassigned (a.b.c, reassign c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a.b.c = {};\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('remove event from old target when reassigned (a.b, reassign a)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\ta = obj.a;\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tobj.a = {\n\t\t\tb: {}\n\t\t};\n\t\tmagic.trigger(a.b, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('remove event from old target when reassigned (a.b, reassign b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tb = obj.a.b;\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tobj.a.b = {};\n\t\tmagic.trigger(b, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\n\tit('remove event from old target when reassigned (a.b.c, reassign a)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ta = obj.a;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a = {\n\t\t\tb: {\n\t\t\t\tc: {}\n\t\t\t}\n\t\t};\n\t\tmagic.trigger(a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('remove event from old target when reassigned (a.b.c, reassign b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tb = obj.a.b;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a.b = {\n\t\t\tc: {}\n\t\t};\n\t\tmagic.trigger(b.c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('remove event from old target when reassigned (a.b.c, reassign c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tc = obj.a.c;\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tobj.a.b.c = {};\n\t\tmagic.trigger(c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('undelegate (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b', 'someevent');\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('undelegate (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent');\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('doesn\\'t remove change event when undelegate (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', () => {});\n\t\tmagic._delegateListener(obj, 'a.b', 'change:c', f);\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent');\n\t\tobj.a.b.c = 55;\n\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('undelegate by callback (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b', 'someevent', f);\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('undelegate by callback (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent', f);\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\n\tit('undelegate by callback and context (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tctx = {},\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f, ctx);\n\t\tmagic._undelegateListener(obj, 'a.b', 'someevent', f, ctx);\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('undelegate by callback and context (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tctx = {},\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f, ctx);\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent', f, ctx);\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('undelegate by callback but keeps when callbacks are not same (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b', 'someevent', () => {});\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('undelegate by callback but keeps when callbacks are not same (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f);\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent', () => {});\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('undelegate by callback but keeps when contexts are not same (a.b)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b', 'someevent', f, {});\n\t\tmagic._undelegateListener(obj, 'a.b', 'someevent', f, {});\n\n\t\tmagic.trigger(obj.a.b, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('undelegate by callback but keeps when contexts are not same (a.b.c)', () => {\n\t\tlet bool = false,\n\t\t\tf = evt => bool = true,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', f, {});\n\t\tmagic._undelegateListener(obj, 'a.b.c', 'someevent', f, {});\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('uses correct context for delegated events', () => {\n\t\tlet bool = false,\n\t\t\tobj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tctx = {};\n\n\t\tmagic._delegateListener(obj, 'a.b.c', 'someevent', function(evt) {\n\t\t\tbool = this === ctx\n\t\t}, ctx);\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Array)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', evt => bool = true);\n\n\t\tobj.push({});\n\n\t\tmagic.trigger(obj[0], 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Object)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', evt => bool = true);\n\n\t\tobj.jset('x', {});\n\n\t\tmagic.trigger(obj.x, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removes \"*\" events (MK.Array)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', evt => bool = true);\n\n\t\tobj.push({});\n\n\t\tmagic._undelegateListener(obj, '*', 'someevent');\n\n\t\tmagic.trigger(obj[0], 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes \"*\" events (MK.Object)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', evt => bool = true);\n\n\t\tobj.jset('x', {});\n\n\t\tmagic._undelegateListener(obj, '*', 'someevent');\n\n\t\tmagic.trigger(obj.x, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes \"*\" events using callback (MK.Array)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false,\n\t\t\tcallback = evt => bool = true;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', callback);\n\n\t\tobj.push({});\n\n\t\tmagic._undelegateListener(obj, '*', 'someevent', callback);\n\n\t\tmagic.trigger(obj[0], 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes \"*\" events using callback (MK.Object)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false,\n\t\t\tcallback = evt => bool = true;\n\n\t\tmagic._delegateListener(obj, '*', 'someevent', callback);\n\n\t\tobj.jset('x', {});\n\n\t\tmagic._undelegateListener(obj, '*', 'someevent', callback);\n\n\t\tmagic.trigger(obj.x, 'someevent');\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('works with \"*\" events (MK.Array), go deeper (*.a)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.a', 'someevent', evt => bool = true);\n\n\t\tobj.push({\n\t\t\ta: {}\n\t\t});\n\n\t\tmagic.trigger(obj[0].a, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Object), go deeper (*.a)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.a', 'someevent', evt => bool = true);\n\n\t\tobj.jset('x', {\n\t\t\ta: {}\n\t\t});\n\n\t\tmagic.trigger(obj.x.a, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Array), go deeper (*.*)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.*', 'someevent', evt => bool = true);\n\n\t\tobj.push(new MK.Array({}));\n\n\t\tmagic.trigger(obj[0][0], 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Object), go deeper (*.*)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.*', 'someevent', evt => bool = true);\n\n\t\tobj.jset('x', new MK.Object({\n\t\t\ta: {}\n\t\t}));\n\n\t\tmagic.trigger(obj.x.a, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Array), go deeper (*.*.a)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.*.a', 'someevent', evt => bool = true);\n\n\t\tobj.push(new MK.Array({\n\t\t\ta: {}\n\t\t}));\n\n\t\tmagic.trigger(obj[0][0].a, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Object), go deeper (*.*.a)', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener(obj, '*.*.a', 'someevent', evt => bool = true);\n\n\t\tobj.jset('x', new MK.Object({\n\t\t\ty: new MK.Object({\n\t\t\t\ta: {}\n\t\t\t})\n\t\t}));\n\n\t\tmagic.trigger(obj.x.y.a, 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\t/*\n\tTODO\n\tit( 'works with \"...\" events (a.b.c, listen \"...@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, '...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\n\tit( 'works with \"...\" events (a.b.c, listen \"...@someevent\", trigger on b)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, '...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"...c@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, '...c', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, 'a...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...@someevent\", trigger on b)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, 'a...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...c@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._delegateListener( obj, 'a...c', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\t// ---\n\tit( 'removes \"...\" events (a.b.c, listen \"...@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, '...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\n\tit( 'works with \"...\" events (a.b.c, listen \"...@someevent\", trigger on b)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, '...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"...c@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, '...c', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, 'a...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...@someevent\", trigger on b)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, 'a...', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit( 'works with \"...\" events (a.b.c, listen \"a...c@someevent\", trigger on c)', () => {\n\t\tlet obj = { a: { b: { c: {} } } },\n\t\t\tbool = false;\n\n\t\tmagic._undelegateListener( obj, 'a...c', 'someevent', evt => bool = true );\n\n\t\tmagic.trigger( obj.a.b.c, 'someevent' );\n\n\t\texpect(bool).toBe(false);\n\t});*/\n\n\n\n\t/*'a.b.c@change:x';\n\n\t'a@b@c@change:x'; // polyfill\n\t'@change:x'; // polyfill\n\n\t'...@change:x';  // MK.Array, MK.Object\n\t'a...@change:x'; // MK\n\t'*@modify'; // MK.Array, MK.Object\n\t'*.*@modify';  // MK.Array, MK.Object\n\t'*.*.*@modify';  // MK.Array, MK.Object\n\t'{a}.{b}.{c}@modify'; // MK.Array, MK.Object\n\n\t'*.a...@change:x';\n\t'*.{a}.{b}...@change:x'*/\n});","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,1,1,null,1,null,null,null,null,null,null,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,1,null,1,null,null,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,1,null,1,null,null,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,1,null,1,1,null,0,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,0,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,1,null,null,null,null,null,null,null,null,null,1,1,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,1,null,1,null,1,1,null,null,1,0,null,null,1,null,1,null,1,null,1,null,1,1,null,null,1,0,null,null,1,null,1,null,1,null,1,null,1,1,null,null,0,null,null,1,null,1,null,1,null,1,null,1,null,1,1,null,null,0,null,null,1,null,1,null,1,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,null,null,1,null,1,null,1,1,null,null,1,1,null,null,1,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/events/events_dom_spec.es","source":"import magic from 'matreshka-magic';\nimport $ from 'bquery';\nlet q = (s, c) => {\n\tlet result = $(s, c)[0] || null;\n\tif (result) {\n\t\tresult.click = result.click || (() => {\n\t\t\tlet ev = document.createEvent(\"MouseEvent\");\n\t\t\tev.initMouseEvent(\n\t\t\t\t\"click\",\n\t\t\t\ttrue /* bubble */ , true /* cancelable */ ,\n\t\t\t\twindow, null,\n\t\t\t\t0, 0, 0, 0, /* coordinates */\n\t\t\t\tfalse, false, false, false, /* modifier keys */\n\t\t\t\t0 /*left*/ , null\n\t\t\t);\n\t\t\tresult.dispatchEvent(ev);\n\t\t})\n\t}\n\treturn result;\n}\n\ndescribe(\"Events core: _addDOMListener, _removeDOMListener\", () => {\n\tdocument.body.appendChild($.create({\n\t\ttagName: 'DIV',\n\t\tid: 'd-test',\n\t\tinnerHTML: `\n\t\t\t<div id=\"d-test-1\">\n\t\t\t\t<div class=\"d-test-2\">\n\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`\n\t}));\n\n\n\n\tit('fires (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic._addDOMListener(obj, 'x', 'click', null, evt => bool = true);\n\n\n\t\tq('#d-test').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removes (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic._addDOMListener(obj, 'x', 'click', null, evt => bool = true);\n\t\tmagic._removeDOMListener(obj, 'x', 'click');\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\n\t\tq('#d-test').click();\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('fires (use selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', evt => bool = true);\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\n\n\tit('adds (use selector) and removes (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', evt => bool = true);\n\t\tmagic._removeDOMListener(obj, 'x', 'click');\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('adds (use selector) then binds then removes (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', evt => bool = true);\n\t\tmagic._removeDOMListener(obj, 'x', 'click');\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('triggers DOM event', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', null, (d1, d2) => bool = d1 === 1 && d2 === 2);\n\t\tmagic.trigger(obj, 'click::x', 1, 2);\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('triggers DOM event with specified selector', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', (d1, d2) => bool = d1 === 1 && d2 === 2);\n\t\tmagic.trigger(obj, 'click::x(.d-test-2)', 1, 2);\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('triggers DOM event with specified selector (bubbling test)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', null, (d1, d2) => bool = d1 === 1 && d2 === 2);\n\t\tmagic.trigger(obj, 'click::x(.d-test-2)', 1, 2);\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\n\tit('removes delegated', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', evt => bool = true);\n\t\tmagic._removeDOMListener(obj, 'x', 'click', '.d-test-2');\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('removes delegated and doesn\\'t remove events from other nodes', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic._addDOMListener(obj, 'x', 'click', '.d-test-2', evt => bool = true);\n\t\tmagic._removeDOMListener(obj, 'x', 'click', '.blah');\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n});\n","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,7,null,7,7,12,12,12,null,null,null,7,null,null,1,1,null,null,null,null,1,1,null,null,1,null,1,15,null,null,1,1,null,1,1,null,null,1,0,null,null,1,null,1,null,1,1,null,1,1,null,null,1,null,1,9,null,null,1,1,null,1,1,null,null,1,null,1,0,null,null,1,null,1,1,null,1,1,null,null,1,null,1,0,null,null,1,null,1,1,null,1,1,null,null,1,null,1,10,null,null,1,null,1,null,1,1,null,null,1,null,1,6,null,null,1,null,1,null,1,1,null,null,1,null,1,8,null,null,1,null,1,null,1,1,null,null,1,null,1,0,null,null,1,null,1,1,null,1,1,null,null,1,null,1,3,null,null,1,null,1,1]},{"name":"test/src/events/events_summary_spec.es","source":"import magic from 'matreshka-magic';\nimport MK from 'matreshka';\nimport $ from 'bquery';\nlet q = (s, c) => {\n\tlet result = $(s, c)[0] || null;\n\tif (result) {\n\t\tresult.click = result.click || (() => {\n\t\t\tlet ev = document.createEvent(\"MouseEvent\");\n\t\t\tev.initMouseEvent(\n\t\t\t\t\"click\",\n\t\t\t\ttrue /* bubble */ , true /* cancelable */ ,\n\t\t\t\twindow, null,\n\t\t\t\t0, 0, 0, 0, /* coordinates */\n\t\t\t\tfalse, false, false, false, /* modifier keys */\n\t\t\t\t0 /*left*/ , null\n\t\t\t);\n\t\t\tresult.dispatchEvent(ev);\n\t\t});\n\t}\n\treturn result;\n}\n\n\n\ndescribe('Events summary (on, off)', () => {\n\tlet node = document.body.appendChild($.create({\n\t\ttagName: 'DIV',\n\t\tid: 's-test',\n\t\tinnerHTML: `\n\t\t\t<div id=\"s-test-1\">\n\t\t\t\t<div class=\"s-test-2\">\n\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`\n\t}));\n\n\tnode.click = node.click || function() {\n\t\tthis.dispatchEvent(new MouseEvent('click'));\n\t}\n\n\tit('fires', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\t\tmagic.on(obj, 'someevent', evt => bool = true);\n\t\tmagic.trigger(obj, 'someevent');\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires delegated', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic.on(obj, 'a.b.c@someevent', evt => bool = true);\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removed delegated', () => {\n\t\tlet obj = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbool = false;\n\n\t\tmagic.on(obj, 'a.b.c@someevent', evt => bool = true);\n\t\tmagic.off(obj, 'a.b.c@someevent');\n\n\t\tmagic.trigger(obj.a.b.c, 'someevent');\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('fires (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic.on(obj, 'click::x', evt => bool = true);\n\n\n\t\tq('#d-test').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('removes (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic.on(obj, 'click::x', evt => bool = true);\n\t\tmagic.off(obj, 'click::x');\n\n\t\tq('#d-test').click();\n\n\t\texpect(bool).toBe(false);\n\t});\n\n\tit('fires (use selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test');\n\t\tmagic.on(obj, 'click::x(.d-test-2)', evt => bool = true);\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('works with \"*\" events (MK.Array)', () => {\n\t\tlet obj = new MK.Array(),\n\t\t\tbool = false;\n\n\t\tmagic.on(obj, '@someevent', evt => bool = true);\n\n\t\tobj.push({});\n\n\t\t//magic._off( obj, '*@someevent'  );\n\n\t\tmagic.trigger(obj[0], 'someevent');\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (no selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic.on(obj, 'click::x', evt => bool = true);\n\n\n\t\tq('#d-test').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('fires (use selector)', () => {\n\t\tlet obj = {},\n\t\t\tbool = false;\n\n\t\tmagic.bindNode(obj, 'x', '#d-test')\n\t\tmagic.on(obj, 'click::x(.d-test-2)', evt => bool = true);\n\n\t\tq('.d-test-2').click();\n\n\t\texpect(bool).toBe(true);\n\t});\n\n\tit('triggers once', () => {\n\t\tlet obj = {},\n\t\t\ti = 0,\n\t\t\tf = evt => i++;\n\n\t\tmagic.once(obj, 'someevent', f);\n\t\tmagic.trigger(obj, 'someevent');\n\t\tmagic.trigger(obj, 'someevent');\n\t\tmagic.trigger(obj, 'someevent');\n\n\t\texpect(i).toBe(1);\n\t});\n\n\n\tit('onDebounce works', done => {\n\t\tlet obj = {},\n\t\t\ti = 0,\n\t\t\tf = evt => i++;\n\n\t\tsetTimeout(() => {\n\t\t\texpect(i).toBe(1);\n\t\t\tdone();\n\t\t}, 800);\n\n\t\tmagic.onDebounce(obj, 'someevent', f);\n\t\tmagic.trigger(obj, 'someevent');\n\t\tmagic.trigger(obj, 'someevent');\n\t\tmagic.trigger(obj, 'someevent');\n\t});\n});\n","coverage":[null,null,1,1,null,1,null,1,null,1,3,null,null,null,null,1,5,null,5,5,0,0,0,null,null,null,5,null,null,1,1,null,null,null,null,null,1,0,null,null,1,1,null,null,1,1,null,null,1,null,1,null,1,1,null,null,null,null,null,null,null,null,1,1,null,null,1,null,1,null,1,1,null,null,null,null,null,null,null,null,1,0,null,null,1,null,1,null,1,null,1,1,null,null,1,null,1,5,null,null,1,1,null,1,1,null,null,1,null,1,0,null,null,1,null,1,1,null,1,1,null,null,1,null,1,2,null,null,1,1,null,1,1,null,null,1,1,null,null,1,null,1,null,1,null,1,1,null,null,1,null,1,2,null,null,1,1,null,1,1,null,null,1,null,1,1,null,null,1,1,null,1,1,null,null,1,null,null,1,null,1,null,1,null,1,null,1,null,1,1,null,null,1,null,null,1,1,1,null,null,1,null,1,null,1,null,1]},{"name":"test/src/common/set_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe(\"set\", () => {\n\tit('sets', () => {\n\t\tlet obj = {};\n\n\t\tmagic.set(obj, 'x', 3)\n\n\t\texpect(obj.x).toEqual(3);\n\t});\n});","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,1,null,1]},{"name":"test/src/mk_array/array_common_spec.es","source":"import MK from 'matreshka';\n\ndescribe('Common tests for MK.Array', () => {\n\tit('throws error if Model is undefined', () => {\n\t\tlet bool = false,\n\t\t\tMyClass;\n\t\ttry {\n\t\t\tnew MK.Class({\n\t\t\t\t'extends': MK.Array,\n\t\t\t\tModel: undefined,\n\t\t\t\tconstructor() {\n\t\t\t\t\tthis._initMK();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch(e) {\n\t\t\tbool = true;\n\t\t}\n\n\t\texpect(bool).toEqual(true);\n\t});\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,1,1,null,null,null,1,null,null,null,1,null,null,1]},{"name":"test/src/mk_array/array_custom_methods_spec.es","source":"import MK from 'matreshka';\n\ndescribe('MK.Array custom methods', () => {\n\tit('pulls', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tremoved;\n\t\tarr.push('a', 'b', 'c');\n\t\tremoved = arr.pull(1);\n\n\t\texpect(removed).toEqual('b');\n\t\texpect(arr.toArray()).toEqual(['a', 'c']);\n\t\texpect(arr.length).toEqual(2);\n\t});\n\n\tit('pulls object', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject1 = {},\n\t\t\tobject2 = {},\n\t\t\tobject3 = {},\n\t\t\tremoved;\n\n\t\tarr.push(object1, object2, object3);\n\n\t\tremoved = arr.pull(object2);\n\n\t\texpect(removed === object2).toBe(true);\n\n\t\texpect(arr.length).toEqual(2);\n\t});\n\n\tit('recreates', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject1 = {},\n\t\t\tobject2 = {},\n\t\t\tobject3 = {};\n\n\t\tarr.recreate([object1, object2, object3]);\n\n\t\texpect(arr.length).toEqual(3);\n\t\texpect(arr[0] === object1).toBe(true);\n\t\texpect(arr[1] === object2).toBe(true);\n\t\texpect(arr[2] === object3).toBe(true);\n\n\t\tarr.recreate();\n\n\t\texpect(arr.length).toEqual(0);\n\t\texpect(arr[0] === undefined).toBe(true);\n\t\texpect(arr[1] === undefined).toBe(true);\n\t\texpect(arr[2] === undefined).toBe(true);\n\t});\n\n\tit('emptifies', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject1 = {},\n\t\t\tobject2 = {},\n\t\t\tobject3 = {};\n\n\t\tarr.recreate([object1, object2, object3]);\n\n\t\texpect(arr.length).toEqual(3);\n\t\tarr.recreate();\n\n\t\texpect(arr.length).toEqual(0);\n\t\texpect(arr[0] === undefined).toBe(true);\n\t\texpect(arr[1] === undefined).toBe(true);\n\t\texpect(arr[2] === undefined).toBe(true);\n\t});\n\n\tit('tracks by _id', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject0 = {_id: 0, a: 0},\n\t\t\tobject1 = {_id: 1, a: 1},\n\t\t\tobject2 = {_id: 2, a: 2},\n\t\t\tobject3 = {_id: 0, a: 3},\n\t\t\tobject4 = {_id: 1, a: 4},\n\t\t\tobject5 = {_id: 3, a: 5};\n\n\t\tarr.trackBy = '_id';\n\n\t\tarr.recreate([object0, object1, object2]);\n\n\t\texpect(arr[0] === object0).toBe(true);\n\t\texpect(arr[1] === object1).toBe(true);\n\t\texpect(arr[2] === object2).toBe(true);\n\n\t\tarr.recreate([object4, object5, object3]);\n\n\t\texpect(arr[0] === object1).toBe(true);\n\t\texpect(arr[1] === object5).toBe(true);\n\t\texpect(arr[2] === object0).toBe(true);\n\n\n\n\n\t});\n\n\tit('tracks by _id', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject0 = {_id: 0, a: 0},\n\t\t\tobject1 = {_id: 1, a: 1},\n\t\t\tobject2 = {_id: 2, a: 2},\n\t\t\tobject3 = {_id: 0, a: 3},\n\t\t\tobject4 = {_id: 1, a: 4},\n\t\t\tobject5 = {_id: 3, a: 5};\n\n\t\tarr.trackBy = '_id';\n\n\t\tarr.recreate([object0, object1, object2]);\n\n\t\texpect(arr[0] === object0).toBe(true);\n\t\texpect(arr[1] === object1).toBe(true);\n\t\texpect(arr[2] === object2).toBe(true);\n\n\t\tarr.recreate([object4, object5, object3]);\n\n\t\texpect(arr[0] === object1).toBe(true);\n\t\texpect(arr[1] === object5).toBe(true);\n\t\texpect(arr[2] === object0).toBe(true);\n\n\n\t\texpect(arr[0].a).toEqual(4);\n\t\texpect(arr[1].a).toEqual(5);\n\t\texpect(arr[2].a).toEqual(3);\n\n\n\t});\n\n\n\tit('tracks by $index', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tobject0 = {a: 0},\n\t\t\tobject1 = {a: 1},\n\t\t\tobject2 = {a: 2},\n\t\t\tobject3 = {a: 3},\n\t\t\tobject4 = {a: 4},\n\t\t\tobject5 = {a: 5},\n\t\t\tobject6 = {a: 6};\n\n\t\tarr.trackBy = '$index';\n\n\t\tarr.recreate([object0, object1, object2]);\n\n\t\texpect(arr[0] === object0).toBe(true);\n\t\texpect(arr[1] === object1).toBe(true);\n\t\texpect(arr[2] === object2).toBe(true);\n\n\t\tarr.recreate([object3, object4, object5, object6]);\n\n\t\texpect(arr[0] === object0).toBe(true);\n\t\texpect(arr[1] === object1).toBe(true);\n\t\texpect(arr[2] === object2).toBe(true);\n\t\texpect(arr[3] === object6).toBe(true);\n\n\n\t\texpect(arr[0].a).toEqual(3);\n\t\texpect(arr[1].a).toEqual(4);\n\t\texpect(arr[2].a).toEqual(5);\n\t\texpect(arr[3].a).toEqual(6);\n\t});\n\n\t// tests for orderby is borrowed from lodash\n   var objects = [\n\t { 'a': 'x', 'b': 3 },\n\t { 'a': 'y', 'b': 4 },\n\t { 'a': 'x', 'b': 1 },\n\t { 'a': 'y', 'b': 2 }\n   ];\n\n   it('should sort by a single property by a specified order', () => {\n   \tlet actual = new MK.Array().recreate(objects).orderBy('a', 'desc').toArray();\n   \texpect(actual).toEqual([objects[1], objects[3], objects[0], objects[2]]);\n   });\n\n   it('should sort by multiple properties by specified orders', () => {\n   \tlet actual = new MK.Array().recreate(objects).orderBy(['a', 'b'], ['desc', 'asc']).toArray();\n   \texpect(actual).toEqual([objects[3], objects[1], objects[2], objects[0]]);\n   });\n\n   it('should sort by a property in ascending order when its order is not specified', () => {\n   \tlet falsey = [, '', 0, false, NaN, null, undefined],\n\n   \t\texpected = [objects[2], objects[0], objects[3], objects[1]],\n   \t\tactual = new MK.Array().recreate(objects).orderBy(['a', 'b']).toArray();\n\n   \texpect(actual).toEqual(expected);\n\n   \tfalsey.forEach(function(order, index) {\n   \t\tactual = new MK.Array().recreate(objects).orderBy(['a', 'b'], index ? ['desc', order] : ['desc']).toArray();\n   \t\texpected = [objects[3], objects[1], objects[2], objects[0]];\n   \t\texpect(actual).toEqual(expected);\n   \t});\n\n   });\n\n   it('should work with `orders` specified as string objects', () => {\n   \tlet actual = new MK.Array().recreate(objects).orderBy(['a'], [Object('desc')]).toArray();\n   \texpect(actual).toEqual([objects[1], objects[3], objects[0], objects[2]]);\n   });\n\n\n\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,1,1,1,1,1,null,1,1,null,null,null,null,1,1,1,1,null,1,1,null,null,null,1,1,1,1,1,1,1,1,1,1,null,1,1,null,null,null,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,1,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,1,1,null,1,1,null,null,1,1,6,6,6,null,null,1,1,1]},{"name":"test/src/mk_array/array_native_methods_spec.es","source":"import MK from 'matreshka';\n\ndescribe('MK.Array native methods', () => {\n\tit('pushes', () => {\n\t\tlet arr = new MK.Array();\n\n\t\tarr.push(1, 2);\n\n\t\texpect(arr[0]).toEqual(1);\n\t\texpect(arr[1]).toEqual(2);\n\t\texpect(arr.length).toEqual(2);\n\t});\n\n\tit('pops', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2);\n\t\tarr.pop();\n\n\t\texpect(arr.length).toEqual(1);\n\t\texpect(arr.toNative()).toEqual([1]);\n\t});\n\n\tit('unshifts', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2);\n\t\tarr.unshift(2, 3, 4);\n\n\t\texpect(arr[0]).toEqual(2);\n\t\texpect(arr[1]).toEqual(3);\n\t\texpect(arr[2]).toEqual(4);\n\n\t\texpect(arr.toNative()).toEqual([2, 3, 4, 1, 2]);\n\t\texpect(arr.length).toEqual(5);\n\t});\n\n\tit('shifts', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\tarr.shift();\n\t\texpect(arr.length).toEqual(2);\n\n\t\texpect(arr.toNative()).toEqual([2, 3]);\n\t});\n\n\tit('sorts', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(2, 3, 1);\n\n\t\tarr.sort();\n\t\texpect(arr.toNative()).toEqual([1, 2, 3]);\n\t});\n\n\tit('reverses', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\tarr.reverse();\n\n\t\texpect(arr.toNative()).toEqual([3, 2, 1]);\n\t});\n\n\tit('splices', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\tnewArr;\n\n\t\tarr.push(1, 2, 3);\n\t\tnewArr = arr.splice(1, 1, 3, 4, 5);\n\n\t\texpect(arr.toNative()).toEqual([1, 3, 4, 5, 3]);\n\t\texpect(newArr.toNative()).toEqual([2]);\n\t});\n\n\tit('filters', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3, 4, 5);\n\t\tarr = arr.filter(item => item > 3);\n\n\t\texpect(arr.toNative()).toEqual([4, 5]);\n\t});\n\n\tit('maps', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\tarr = arr.map(item => item * 2);\n\n\t\texpect(arr.toNative()).toEqual([2, 4, 6]);\n\t});\n\n\tit('runs every', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\texpect(arr.every(item => item < 4)).toBe(true);\n\t\texpect(arr.every(item => item > 4)).toBe(false);\n\t});\n\n\tit('runs some', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\texpect(arr.some(item => item === 2)).toBe(true);\n\t\texpect(arr.some(item => item === 4)).toBe(false);\n\t});\n\n\n\tit('concats', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\n\t\texpect(arr.concat([4, 5, 6]).toNative()).toEqual([1, 2, 3, 4, 5, 6]);\n\t\texpect(arr.concat(MK.Array.from([4, 5, 6])).toNative()).toEqual([1, 2, 3, 4, 5, 6]);\n\t});\n\n\tit('joins', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\texpect(arr.join(' ')).toEqual('1 2 3');\n\t});\n\n\tit('converts to string', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\texpect(arr.toString()).toEqual('1,2,3');\n\t});\n\n\tit('finds index of', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3, 3, 4, 5);\n\t\texpect(arr.indexOf(3)).toEqual(2);\n\t\texpect(arr.indexOf(6)).toEqual(-1);\n\t});\n\n\tit('finds last index of', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3, 3, 4, 5);\n\t\texpect(arr.lastIndexOf(3)).toEqual(3);\n\t\texpect(arr.lastIndexOf(6)).toEqual(-1);\n\t});\n\n\tit('slices', () => {\n\t\tlet arr = new MK.Array();\n\t\tarr.push(1, 2, 3);\n\t\texpect(arr.slice(1).toNative()).toEqual([2, 3]);\n\t});\n\n\tit('iterates', () => {\n\t\tlet arr = new MK.Array(),\n\t\t\ti = 0;\n\n\t\tarr.push(1, 2, 3);\n\n\t\tarr.forEach(item => i++);\n\t\texpect(i).toEqual(arr.length);\n\t});\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,1,1,1,1,null,1,1,1,1,1,1,null,1,1,1,1,1,1,1,1,1,null,1,1,1,1,1,1,null,1,1,1,1,1,null,1,1,1,1,1,null,1,1,null,1,1,1,1,null,1,1,1,1,5,null,1,null,1,1,1,1,3,null,1,null,1,1,1,1,3,null,1,1,null,null,1,1,1,1,2,null,1,3,null,null,1,1,1,1,1,null,1,1,1,1,null,1,1,1,1,null,1,1,1,1,1,null,1,1,1,1,1,null,1,1,1,1,null,1,1,null,1,1,3,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/mk_array/array_renderer_spec.es","source":"import MK from 'matreshka';\nimport $ from 'bquery';\nlet q = (s, c) => $(s, c)[0] || null;\n\ndescribe('MK.Array#renderer', () => {\n\tlet n = 10;\n\tfunction createArr() {\n\t\tclass Model extends MK.Object {\n\t\t\tconstructor(obj) {\n\t\t\t\tsuper();\n\t\t\t\tthis\n\t\t\t\t\t.jset(obj)\n\t\t\t\t\t.on('render', evt => this.bindNode('x', ':sandbox span', MK.binders.innerHTML()));\n\t\t\t}\n\t\t}\n\n\t\tclass Arr extends MK.Array {\n\t\t\tModel = Model;\n\n\t\t\tconstructor(...args) {\n\t\t\t\tsuper(...args);\n\t\t\t\tthis.bindNode('sandbox', $.create('div', {\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\trole: 'parent'\n\t\t\t\t\t}\n\t\t\t\t}))\n\t\t\t}\n\t\t}\n\n\t\treturn new Arr();\n\t}\n\n\n\n\n\tit('renders', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\t\tarr.itemRenderer = () => `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\n\tit('forces rendering', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => {\n\t\t\treturn `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\t\t};\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\tarr.rerender({\n\t\t\tforceRerender: true\n\t\t});\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n * 2);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\n\tit('rerenders when renderer is changed', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\tarr.itemRenderer = () => `<div role=\"child2\" index=\"${index++}\"><span></span></div>`;\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n * 2);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\n\tit('rerenders when rendered is changed (forceRerender: false)', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\n\t\tfor (let i = 0; i < n/2; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\tfor (let i = 0; i < n/2; i++) {\n\t\t\tarr.push_({\n\t\t\t\tx: i + n/2\n\t\t\t}, {\n\t\t\t\tdontRender: true\n\t\t\t});\n\t\t}\n\n\t\tarr.set('itemRenderer', () => `<div role=\"child2\" index=\"${index++}\"><span></span></div>`, {\n\t\t\tforceRerender: false\n\t\t});\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\tit('removes rendered nodes', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\tarr.recreate();\n\n\t\texpect(arr.length).toEqual(0);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length).toEqual(0);\n\t});\n\n\n\tit('renders if silent: true', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `<div role=\"child\" index=\"${index++}\"><span></span></div>`;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push_({\n\t\t\t\tx: i\n\t\t\t}, {\n\t\t\t\tsilent: true\n\t\t\t});\n\t\t}\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\n\tit('uses bindings parser', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\n\n\t\tarr.itemRenderer = () => `<div role=\"child3\" index=\"${index++}\"><span attr=\"hey {{x}}\"></span></div>`;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\n\n\t\texpect(q('[attr]', arr[5].sandbox).getAttribute('attr')).toEqual('hey ' + 5);\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length).toEqual(n);\n\t});\n\n\n\tit('wraps invalid renderer with <span>', () => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `Hi there <div><span attr=\"hey {{x}}\" index=\"${index++}\"></span></div>{{x}}`;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\t\texpect(arr.sandbox.children[0].tagName).toEqual('SPAN');\n\t\texpect(arr.sandbox.children[1].childNodes.length).toEqual(3);\n\t\texpect(arr.sandbox.children[2].childNodes[0].textContent).toEqual('Hi there ');\n\t\texpect(arr.sandbox.children[3].childNodes[1].tagName).toEqual('DIV');\n\t\texpect(arr.sandbox.children[4].childNodes[2].textContent).toEqual('4');\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(index).toEqual(n);\n\t\texpect(arr.sandbox.children.length)\n\t});\n\n\tit('allows to use selector', () => {\n\t\tlet arr = createArr();\n\n\t\tarr.sandbox.appendChild($.create('div', {\n\t\t\tinnerHTML: `Hi there <div><span attr=\"hey {{x}}\"></span></div>{{x}}`,\n\t\t\tclassName: 'item-renderer'\n\t\t}));\n\n\t\tarr.itemRenderer = ':sandbox .item-renderer';\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\texpect(arr.sandbox.children[0].tagName).toEqual('DIV');\n\t\t// the first node is itemrenderer node\n\t\texpect(arr.sandbox.children[1].childNodes[2].textContent).toEqual('0');\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(arr.sandbox.children.length);\n\t});\n\n\tit('restores from container', () => {\n\t\tlet arr = createArr(),\n\t\t\t//div = $.create('div'),\n\t\t\tHTML = '';\n\n\t\tfor(let i = 0; i < n; i++) {\n\t\t\tHTML += '<div><span>Hi there</span></div>'\n\t\t}\n\n\t\tarr.sandbox.innerHTML = HTML;\n\n\t\tarr.restore();\n\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(arr.sandbox.children[0].textContent).toEqual('Hi there');\n\t});\n\n\tit('restores from node with custom selector', () => {\n\t\tlet arr = createArr(),\n\t\t\tHTML = '';\n\n\t\tfor(let i = 0; i < n; i++) {\n\t\t\tHTML += `<div class=\"${i >= 5 ? 'fit' : 'nope'}\"><span>Hi there</span></div>`\n\t\t}\n\n\t\tarr.sandbox.innerHTML = HTML;\n\t\tarr.restore(':sandbox .fit');\n\t\texpect(arr.length).toEqual(5);\n\t\texpect(arr.sandbox.children[0].textContent).toEqual('Hi there');\n\t});\n\n\tit('restores from external node', () => {\n\t\tlet arr = createArr(),\n\t\t\tdiv = $.create('div', {className: 'restore-items'}),\n\t\t\tHTML = '';\n\n\t\tfor(let i = 0; i < n; i++) {\n\t\t\tHTML += '<div><span>Hi there</span></div>'\n\t\t}\n\n\t\tdiv.innerHTML = HTML;\n\t\tdocument.body.appendChild(div);\n\t\tarr.restore('.restore-items > div');\n\t\tdocument.body.removeChild(div);\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(arr[0].sandbox.textContent).toEqual('Hi there');\n\t});\n\n\tit('sorts', () => {\n\t\tlet arr = createArr();\n\n\t\tarr.itemRenderer = '<span><span></span></span>';\n\n\t\tfor(var i = 0; i < n; i++) {\n\t\t\tarr.push({x: i});\n\t\t}\n\n\t\tarr.reverse();\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(arr[0].sandbox.textContent).toEqual(String(n-1));\n\t\texpect(arr[n-1].sandbox.textContent).toEqual(String(0));\n\t\texpect(arr.sandbox.children[0].textContent).toEqual(String(n-1));\n\t\texpect(arr.sandbox.children[n-1].textContent).toEqual(String(0));\n\n\t\tarr.sort((a, b) => a.x > b.x ? 1 : -1);\n\n\t\texpect(arr[0].sandbox.textContent).toEqual(String(0));\n\t\texpect(arr[n-1].sandbox.textContent).toEqual(String(n-1));\n\t\texpect(arr.sandbox.children[0].textContent).toEqual(String(0));\n\t\texpect(arr.sandbox.children[n-1].textContent).toEqual(String(n-1));\n\t});\n\n\n\tit('orders by key', () => {\n\t\t// detailed test for orderby is\n\t\tlet arr = createArr();\n\n\t\tarr.itemRenderer = '<span><span></span></span>';\n\n\t\tfor(var i = 0; i < n; i++) {\n\t\t\tarr.push({x: i});\n\t\t}\n\n\t\tarr.orderBy('x', 'desc');\n\t\texpect(arr.length).toEqual(n);\n\t\texpect(arr[0].sandbox.textContent).toEqual(String(n-1));\n\t\texpect(arr[n-1].sandbox.textContent).toEqual(String(0));\n\t\texpect(arr.sandbox.children[0].textContent).toEqual(String(n-1));\n\t\texpect(arr.sandbox.children[n-1].textContent).toEqual(String(0));\n\n\t\tarr.orderBy('x', 'asc');\n\n\t\texpect(arr[0].sandbox.textContent).toEqual(String(0));\n\t\texpect(arr[n-1].sandbox.textContent).toEqual(String(n-1));\n\t\texpect(arr.sandbox.children[0].textContent).toEqual(String(0));\n\t\texpect(arr.sandbox.children[n-1].textContent).toEqual(String(n-1));\n\t});\n\n\tit('triggers \"afterrender\" event', done => {\n\t\tlet arr = createArr(),\n\t\t\tindex = 0;\n\n\t\tarr.itemRenderer = () => `<div role=\"child\"><span></span></div>`;\n\n\t\tarr.on('*@afterrender', evt => {\n\t\t\texpect(arr.indexOf(evt.self)).toEqual(index++);\n\t\t\texpect(arr.sandbox).toEqual(evt.self.sandbox.parentNode);\n\t\t\tif(index == n) {\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tarr.push({\n\t\t\t\tx: i\n\t\t\t});\n\t\t}\n\n\t\texpect(arr.length).toEqual(n);\n\n\t});\n});\n","coverage":[null,null,160,null,1,1,null,1,null,1,2,null,null,null,null,1,160,0,null,null,null,1,160,0,null,null,160,null,null,1,30,0,null,null,30,null,null,null,null,null,null,null,30,null,null,1,1,null,null,1,1,null,1,15,15,null,1,145,null,145,null,145,160,null,null,145,null,null,15,null,null,15,15,null,1,15,null,15,null,15,0,null,null,15,null,15,null,15,null,null,null,null,null,15,null,null,15,null,null,15,null,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,1,1,1,null,1,1,null,null,1,20,null,null,1,10,null,null,null,null,1,null,null,1,1,1,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,1,10,null,null,1,1,1,null,1,1,null,null,1,5,null,null,1,5,null,null,null,null,1,5,null,null,null,null,null,null,1,5,null,null,null,1,1,1,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,1,1,1,1,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,null,null,1,1,1,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,1,1,1,1,null,1,1,null,null,1,10,null,null,1,10,null,null,null,null,1,1,1,1,1,1,1,1,null,1,1,1,null,null,null,1,null,1,10,null,null,null,null,1,1,1,1,null,1,1,null,null,1,10,null,null,1,1,1,1,null,1,1,null,null,1,10,null,null,1,1,1,1,null,1,1,null,null,null,null,null,1,10,null,null,1,1,1,1,1,1,null,1,1,1,null,1,10,null,null,null,null,1,1,1,1,1,1,1,45,null,1,1,1,1,null,1,1,1,null,1,10,null,null,null,null,1,1,1,1,1,1,1,1,1,1,1,null,1,1,null,null,1,10,null,null,1,10,10,null,10,1,null,null,null,1,10,null,null,null,null,1]},{"name":"test/src/mk_object/datakeys_spec.es","source":"import MK from 'matreshka';\n\ndescribe('MK.Object data keys', () => {\n\n\n\tit('accepts object', () => {\n\t\tlet obj = new MK.Object({\n\t\t\ta: 1\n\t\t});\n\t\texpect(obj.keys()).toEqual(['a']);\n\t});\n\n\tit('jsets', () => {\n\t\tlet obj = new MK.Object({\n\t\t\ta: 1\n\t\t});\n\t\tobj.jset('b', 2);\n\t\texpect(obj.b).toEqual(2);\n\t\texpect(obj.keys()).toEqual(['a', 'b']);\n\t});\n\n\tit('adds data keys', () => {\n\t\tlet obj = new MK.Object({\n\t\t\ta: 1\n\t\t});\n\t\tobj.addDataKeys('c d');\n\t\texpect(obj.keys()).toEqual(['a', 'c', 'd']);\n\t});\n\n\tit('removes data keys', () => {\n\t\tlet obj = new MK.Object({\n\t\t\ta: 1\n\t\t});\n\t\tobj.removeDataKeys('c d');\n\t\texpect(obj.keys()).toEqual(['a']);\n\t});\n\n\tit('triggers \"modify\" when data keys are added', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.on('modify', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.addDataKeys('c d');\n\t\texpect(bool).toEqual(true);\n\t});\n\n\tit('triggers \"remove\" when data keys are removed', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.addDataKeys('a');\n\n\t\tobj.on('remove', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.removeDataKeys('a');\n\t\texpect(bool).toEqual(true);\n\t});\n\n\tit('triggers \"modify\" when data keys are removed', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.addDataKeys('a');\n\n\t\tobj.on('modify', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.removeDataKeys('a');\n\n\t\texpect(bool).toEqual(true);\n\t});\n\n\tit('doesn\\'t trigger \"modify\" when data keys are not removed', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.addDataKeys('a');\n\n\t\tobj.on('modify', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.removeDataKeys('b');\n\n\t\texpect(bool).toEqual(false);\n\t});\n\n\tit('triggers \"modify\" when data is removed', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.addDataKeys('a');\n\n\t\tobj.on('modify', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.remove('a');\n\n\t\texpect(bool).toEqual(true);\n\t});\n\n\tit('doesn\\'t trigger \"modify\" when non-data is removed', () => {\n\t\tlet obj = new MK.Object(),\n\t\t\tbool = false;\n\n\t\tobj.addDataKeys('a');\n\n\t\tobj.on('modify', evt => {\n\t\t\tbool = true;\n\t\t});\n\n\t\tobj.remove('b');\n\n\t\texpect(bool).toEqual(false);\n\t});\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,1,null,1,1,null,null,1,1,1,null,1,1,null,null,1,1,null,1,1,null,null,1,1,null,1,1,null,1,2,null,1,1,null,1,1,null,1,1,1,null,1,1,null,1,1,null,1,1,1,null,1,1,null,1,1,null,1,1,0,null,1,1,null,1,1,null,1,1,1,null,1,1,null,1,1,null,1,1,0,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/production/magic_spec.es","source":"import magic from 'magic-prod';\nimport magic2 from 'magic-prod-min';\n\ndescribe('magic.js and magic.min.js load', () => {\n\tit('imports AMD modules in ES2015 style from magic.js', () => {\n        expect(typeof magic == 'object').toBe(true);\n\t});\n\n\tit('imports AMD modules in ES2015 style from magic.min.js', () => {\n        expect(typeof magic2 == 'object').toBe(true);\n    });\n\n\tit('imports AMD module from magic.js', done => {\n\t\trequire(['magic-prod'], function(magic) {\n\t\t\texpect(typeof magic == 'object').toBe(true);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('imports AMD module from magic.min.js', done => {\n\t\trequire(['magic-prod-min'], function(magic) {\n\t\t\texpect(typeof magic == 'object').toBe(true);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('imports CJS module from magic.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"magic-prod\") + '.js';\n\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.module.exports.bindNode == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\t\t\twin.module = {exports: {}};\n\t\t\twin.exports = win.module.exports;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n\n    });\n\n\n\tit('imports CJS module from magic.min.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"magic-prod-min\") + '.js';\n\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.module.exports.bindNode == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\t\t\twin.module = {exports: {}};\n\t\t\twin.exports = win.module.exports;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n\n    });\n\n\n\tit('loads global variables if there is no CJS or AMD stuff for magic.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"magic-prod\") + '.js';\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.MatreshkaMagic == 'object').toBe(true);\n\t\t\t\texpect(typeof win.magic == 'object').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n    });\n\n\tit('loads global variables if there is no CJS or AMD stuff for magic.min.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"magic-prod-min\") + '.js';\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.MatreshkaMagic == 'object').toBe(true);\n\t\t\t\texpect(typeof win.magic == 'object').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n    });\n});\n","coverage":[null,null,1,1,null,1,null,1,2,null,null,null,null,1,0,null,8,null,null,1,1,1,null,1,1,null,1,1,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,1,null,null,1,1,null,null,1,null,null,null,null,null,null,null,null]},{"name":"test/src/production/matreshka_spec.es","source":"import {Matreshka, $b as $, Class} from 'matreshka-prod';\nimport {Matreshka as Matreshka2, $b as $2, Class as Class2} from 'matreshka-prod-min';\n\ndescribe('matreshka.js and matreshka.min.js load', () => {\n\tit('imports AMD modules in ES2015 style from matreshka.js', () => {\n        expect(typeof Matreshka == 'function').toBe(true);\n\t\texpect(typeof $ == 'function').toBe(true);\n\t\texpect(typeof Class == 'function').toBe(true);\n    });\n\n\tit('imports AMD modules in ES2015 style from matreshka.min.js', () => {\n        expect(typeof Matreshka2 == 'function').toBe(true);\n\t\texpect(typeof $2 == 'function').toBe(true);\n\t\texpect(typeof Class2 == 'function').toBe(true);\n    });\n\n\tit('imports AMD module from matreshka.js', done => {\n\t\trequire(['matreshka-prod'], function(Matreshka) {\n\t\t\texpect(typeof Matreshka == 'function').toBe(true);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('imports AMD module from matreshka.min.js', done => {\n\t\trequire(['matreshka-prod-min'], function(Matreshka) {\n\t\t\texpect(typeof Matreshka == 'function').toBe(true);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('imports CJS module from matreshka.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"matreshka-prod\") + '.js';\n\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.module.exports.Matreshka == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\t\t\twin.module = {exports: {}};\n\t\t\twin.exports = win.module.exports;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n\n    });\n\n\n\tit('imports CJS module from matreshka.min.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"matreshka-prod-min\") + '.js';\n\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.module.exports.Matreshka == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\t\t\twin.module = {exports: {}};\n\t\t\twin.exports = win.module.exports;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n\n    });\n\n\n\tit('loads global variables if there is no CJS or AMD stuff for matreshka.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"matreshka-prod\") + '.js';\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.Matreshka == 'function').toBe(true);\n\t\t\t\texpect(typeof win.MK == 'function').toBe(true);\n\t\t\t\texpect(typeof win.$b == 'function').toBe(true);\n\t\t\t\texpect(typeof win.Class == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n    });\n\n\tit('loads global variables if there is no CJS or AMD stuff for matreshka.min.js', done => {\n\t\tlet iframe = document.createElement('iframe'),\n\t\t\tsrc = require.toUrl(\"matreshka-prod-min\") + '.js';\n\n\n\t\tiframe.onload = () => {\n\t\t\tlet win = iframe.contentWindow,\n\t\t\t\tscript = win.document.createElement('script');\n\n\t\t\tscript.onload = () => {\n\t\t\t\texpect(typeof win.Matreshka == 'function').toBe(true);\n\t\t\t\texpect(typeof win.MK == 'function').toBe(true);\n\t\t\t\texpect(typeof win.$b == 'function').toBe(true);\n\t\t\t\texpect(typeof win.Class == 'function').toBe(true);\n\t\t\t\tdocument.body.removeChild(iframe);\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tscript.src = src;\n\n\t\t\twin.document.body.appendChild(script);\n\n\t\t}\n\n\t\tdocument.body.appendChild(iframe);\n    });\n});\n","coverage":[null,null,1,1,1,1,1,1,null,1,1,1,1,null,1,1,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,null,null,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,1,1,1,null,null,1,1,null,null,1,null,1,1,null,null,1,1,null,null,1,1,1,1,1,1,1,null,null,1,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"test/src/utils/define_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe('define', () => {\n\tit('defines property', () => {\n\t\tlet obj = {},\n\t\t\tval;\n\n\t\tmagic.define(obj, 'a', {\n\t\t\tget() {\n\t\t\t\t\treturn 42;\n\t\t\t\t},\n\t\t\t\tset(v) {\n\t\t\t\t\tval = v;\n\t\t\t\t}\n\t\t});\n\n\t\tobj.a = 1;\n\n\t\texpect(val).toEqual(1);\n\n\t\texpect(obj.a).toEqual(42);\n\t});\n\n\tit('defines setter', () => {\n\t\tlet obj = {},\n\t\t\tval;\n\n\t\tmagic.defineSetter(obj, 'a', v => val = v);\n\n\t\tobj.a = 1;\n\n\t\texpect(val).toEqual(1);\n\t});\n\n\tit('defines getter', () => {\n\t\tlet obj = {};\n\n\t\tmagic.defineGetter(obj, 'a', () => 42);\n\n\t\tobj.a = 1;\n\n\t\texpect(obj.a).toEqual(42);\n\t});\n});","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,1,null,1,null,null,1,null,null,null,1,1,1,null,1,1,null,null,1,1,null,null,1,1,null,1,1,null,1,1,null,null,1,1]},{"name":"test/src/utils/linkprops_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe('linkProps', () => {\n\tit('adds simple dependency', () => {\n\t\tlet obj = {\n\t\t\ta: 1,\n\t\t\tb: 2\n\t\t};\n\n\t\tmagic.linkProps(obj, 'c', 'a b', (a, b) => a + b);\n\n\t\texpect(obj.c).toEqual(3);\n\n\t\tobj.a = 3;\n\n\t\texpect(obj.c).toEqual(5);\n\n\t\tobj.b = 3;\n\n\t\texpect(obj.c).toEqual(6);\n\t});\n\n\tit('adds dependency from another object', () => {\n\t\tlet obj = {\n\t\t\t\ta: 1,\n\t\t\t\tb: 2\n\t\t\t},\n\t\t\tobj2 = {\n\t\t\t\tc: 4,\n\t\t\t\td: 8\n\t\t\t};\n\n\t\tmagic.linkProps(obj, 'e', [\n\t\t\tobj, ['a', 'b'],\n\t\t\tobj2, 'c d'\n\t\t], (a, b, c, d) => a + b + c + d);\n\n\t\texpect(obj.e).toEqual(15);\n\t});\n\n\tit('doesn\\'t sets on init (setOnInit)', () => {\n\t\tlet obj = {\n\t\t\ta: 1,\n\t\t\tb: 2,\n\t\t\tc: 0\n\t\t};\n\n\t\tmagic.linkProps(obj, 'c', 'a b', (a, b) => a + b, false);\n\n\t\texpect(obj.c).toEqual(0);\n\t});\n\n\tit('saves from cyclical links', () => {\n\t\tlet obj = {\n\t\t\ta: 1,\n\t\t\tb: 2,\n\t\t\tc: 3\n\t\t};\n\n\t\tmagic.linkProps(obj, 'a', 'b c', (x, y) => x + y);\n\t\tmagic.linkProps(obj, 'b', 'a c', (x, y) => x + y);\n\t\tmagic.linkProps(obj, 'c', 'a b', (x, y) => x + y);\n\n\t\texpect(obj.a).toEqual(27);\n\t});\n\n\tit('allows deep dependencies', () => {\n\t\tlet obj = {\n\t\t\ta: {b: { c: 1 }}\n\t\t},\n\t\ta,\n\t\tb;\n\n\t\tmagic.linkProps(obj, 'd', 'a.b.c', (c) => c);\n\t\texpect(obj.d).toEqual(1);\n\t\tobj.a.b.c = 2;\n\t\texpect(obj.d).toEqual(2);\n\t\tb = obj.a.b;\n\t\tobj.a.b = {c: 3};\n\t\tb.c = 'nope';\n\t\texpect(obj.d).toEqual(3);\n\t\ta = obj.a;\n\t\tobj.a = {b: {c: 4}};\n\t\ta.b = {c: 'nope'};\n\t\texpect(obj.d).toEqual(4);\n\t});\n\n\tit('allows deep dependencies from another object', () => {\n\t\tlet obj = {\n\t\t\t\ta: 1\n\t\t\t},\n\t\t\tobj2 = {\n\t\t\t\tb: {c: {d: 2}}\n\t\t\t};\n\n\t\tmagic.linkProps(obj, 'd', [\n\t\t\tobj2, 'b.c.d'\n\t\t], (c) => c*2);\n\n\t\texpect(obj.d).toEqual(4);\n\t});\n\n\tit('uses event options', () => {\n\t\tlet obj = {},\n\t\t\ti = 0;\n\n\t\tmagic.linkProps(obj, 'c', 'a b', (a, b) => a + b, {foo: 'bar'});\n\n\t\tmagic.on(obj, 'change:c', evt => {\n\t\t\texpect(evt.foo).toEqual('bar');\n\t\t});\n\n\t\tobj.a = 2;\n\t\tobj.b = 3;\n\t});\n\n\tit('uses silent: true in event options', () => {\n\t\tlet obj = {},\n\t\t\ti = 0;\n\n\t\tmagic.on(obj, 'change:c', evt => {\n\t\t\ti++;\n\t\t});\n\n\t\tmagic.linkProps(obj, 'c', 'a b', (a, b) => a + b, {silent: true});\n\n\t\tobj.a = 2;\n\t\tobj.b = 3;\n\n\t\texpect(i).toEqual(0);\n\t});\n\n\tit('allows to debounce handler', done => {\n\t\tlet obj = {\n\t\t\t\ta: 1,\n\t\t\t\tb: 2\n\t\t\t},\n\t\t\ti = 0;\n\n\t\tmagic.on(obj, 'change:c', evt => {\n\t\t\texpect(obj.c).toEqual(5);\n\t\t});\n\n\t\tmagic.linkProps(obj, 'c', 'a b', (a, b) => {\n\t\t\ti++;\n\t\t\treturn a + b;\n\t\t}, {debounce: true});\n\n\n\t\tobj.a = 2;\n\t\tobj.b = 3;\n\n\t\tsetTimeout(() => {\n\t\t\texpect(i).toEqual(1);\n\t\t\tdone();\n\t\t}, 400);\n\t});\n});\n","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,1,1,null,null,null,null,1,3,null,null,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,1,null,null,1,null,1,1,null,null,null,null,null,1,0,null,null,1,null,1,1,null,null,null,null,null,1,3,null,null,1,2,null,null,1,1,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,1,5,null,null,1,1,1,1,1,null,null,1,1,1,1,null,null,null,null,1,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,null,1,1,null,null,1,3,null,null,null,null,1,2,null,null,1,1,null,1,1,null,null,1,0,null,null,1,3,null,null,null,null,1,1,1,null,1,1,null,null,null,null,null,1,1,null,null,1,1,1,null,null,null,null,1,1,1,1,1]},{"name":"test/src/utils/mediate_spec.es","source":"import magic from 'matreshka-magic';\n\ndescribe('mediate', () => {\n\tit('mediates', () => {\n\t\tlet obj = {};\n\n\t\tmagic.mediate(obj, 'a', v => Number(v));\n\t\tmagic.mediate(obj, 'b c', v => Number(v));\n\n\t\tobj.a = obj.b = obj.c = '123';\n\n\t\texpect(typeof obj.a).toEqual('number');\n\t\texpect(typeof obj.b).toEqual('number');\n\t\texpect(typeof obj.c).toEqual('number');\n\t});\n});","coverage":[null,null,1,1,null,1,1,null,null,null,null,1,0,null,3,null,null,1,1,1,null,1,2,null,null,1,4,null,null,1,1,1,1]}],"git":{"head":{"id":"f0f95b5776356fb85ec1744d953f2ce20d6842f1","author_name":"Andrey Gubanov","author_email":"andrey.a.gubanov@gmail.com","committer_name":"Andrey Gubanov","committer_email":"andrey.a.gubanov@gmail.com","message":"update package"},"branch":"develop","remotes":[{"name":"origin","url":"git@github.com:finom/matreshka.git"}]},"run_at":"2016-01-24T12:06:51.578Z","service_name":"travis-ci","repo_token":"nHgDFoxCBDVqwtjlRX9yPHvFrTmbroRhX"}